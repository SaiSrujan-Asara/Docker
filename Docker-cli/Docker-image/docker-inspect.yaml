ğŸ§  Docker image inspect

The docker image inspect command shows detailed, low-level JSON metadata about a Docker image â€” including configuration, layers, creation time, size, environment variables, entrypoint, exposed ports, labels, and more.

ğŸ“˜ Basic Example:

docker image inspect app:v1

~ âœ  docker images app:v1       
REPOSITORY   TAG       IMAGE ID       CREATED          SIZE
app          v1        8b331c1dc27d   12 minutes ago   166MB

Outputs a huge JSON blob that looks like:

[
    {
        "Id": "sha256:8b331c1dc27df907cc5a1eb24da79d5f5c827e5275b30de6ba57a7746711c161",
        "RepoTags": [
            "app:v1"
        ],
        "RepoDigests": [],
        "Parent": "sha256:f9fbbc2013b5c7b11124529fabb86083cf23d7ac8f639459ff470a3ac49fd370",
        "Comment": "",
        "Created": "2025-10-04T05:51:40.475747297Z",
        "Container": "",
        "ContainerConfig": {
            "Hostname": "",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": false,
            "AttachStderr": false,
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
            ],
            "Cmd": [
                "/bin/sh",
                "-c",
                "#(nop) COPY dir:0c9de0613baa19c7f16d08cf33939e0d08fc25a654501da84b4706b77aa16cac in /app "
            ],
            "Image": "sha256:f9fbbc2013b5c7b11124529fabb86083cf23d7ac8f639459ff470a3ac49fd370",
            "Volumes": null,
            "WorkingDir": "",
            "Entrypoint": null,
            "OnBuild": null,
            "Labels": {
                "org.opencontainers.image.ref.name": "ubuntu",
                "org.opencontainers.image.version": "24.04"
            }
        },
        "DockerVersion": "25.0.5",
        "Author": "",
        "Config": {
            "Hostname": "",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": false,
            "AttachStderr": false,
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
            ],
            "Cmd": [
                "/bin/bash"
            ],
            "Image": "sha256:f9fbbc2013b5c7b11124529fabb86083cf23d7ac8f639459ff470a3ac49fd370",
            "Volumes": null,
            "WorkingDir": "",
            "Entrypoint": null,
            "OnBuild": null,
            "Labels": {
                "org.opencontainers.image.ref.name": "ubuntu",
                "org.opencontainers.image.version": "24.04"
            }
        },
        "Architecture": "amd64",
        "Os": "linux",
        "Size": 166003207,
        "GraphDriver": {
            "Data": {
                "LowerDir": "/var/lib/docker/overlay2/caf60482a82477123463bbb1f8fee1ddf612d6a9557df2d54c546dc844c1f1b7/diff:/var/lib/docker/overlay2/d4aa7e84df9ca8b0ddafa562aca06d5cdc23c80617168ebc48956e9d871af476/diff:/var/lib/docker/overlay2/ef38af02b4cd07edb84a931b4d150b1d174b0b01e54f364c6b41d4b0226225f0/diff",
                "MergedDir": "/var/lib/docker/overlay2/dc3dea5aa0e287a993d52eaae69683d94854117fa038f7db5543b081a4cfedf4/merged",
                "UpperDir": "/var/lib/docker/overlay2/dc3dea5aa0e287a993d52eaae69683d94854117fa038f7db5543b081a4cfedf4/diff",
                "WorkDir": "/var/lib/docker/overlay2/dc3dea5aa0e287a993d52eaae69683d94854117fa038f7db5543b081a4cfedf4/work"
            },
            "Name": "overlay2"
        },
        "RootFS": {
            "Type": "layers",
            "Layers": [
                "sha256:f36fd4bb7334b7ae3321e3229d103c4a3e7c10a263379cc6a058b977edfb46de",
                "sha256:763d4f945917357c8974523c9495faf943828e13023e91dff6423022b5dd6702",
                "sha256:eb122c7fb8af63dec829b7ba3b6f4af208fff9cb9dff12392b53932e70032c2c",
                "sha256:c8a978d6221429cd2fa23ccc4f51067ef570f260b88a6865ee7a8fcfd481d6e2"
            ]
        },
        "Metadata": {
            "LastTagTime": "2025-10-04T05:51:40.821741525Z"
        }
    }
]

---
parent vs container vs container config:

| **Question**                                                      | **Explanation**                                                                                                                                                                                                  |
| ----------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Why is the `Parent` of `app:v1` not equal to `alpine:latest`?** | â€¢ A Dockerfile starting with `FROM alpine:latest` uses Alpine as the **base image**, but that image is **not treated as the `Parent`** in the final metadata.                                                    |
|                                                                   | â€¢ Docker builds the final image through **multiple steps**, such as `RUN`, `COPY`, `CMD`, etc.                                                                                                                   |
|                                                                   | â€¢ Each step creates a **new image layer** on top of the previous one.                                                                                                                                            |
|                                                                   | â€¢ The final image (e.g., `app:v1`) is built on top of the **last created layer**, not directly on `alpine:latest`.                                                                                               |
|                                                                   | â€¢ Therefore, the `Parent` field refers to the **last layer ID**, not the base image ID.                                                                                                                          |
|                                                                   | ğŸ“Œ **Key Point**: `Parent` â‰  `FROM` image â€” it refers to the **previous image layer**, not the base image.                                                                                                       |
|                                                                   | âœ… **Example**: `alpine:latest` has ID `sha256:91ef0a...`, but `app:v1` may show `Parent: sha256:95f6b0...` (from a `RUN apk add curl` step).       
|
| **What is this `"Container"` and `"ContainerConfig"`?**           | â€¢ Docker creates a **temporary container** for each build step (like `RUN`, `COPY`, `CMD`).                                                                                                                      |
|                                                                   | â€¢ These containers are used to execute the build steps.                                                                                                                                                          |
|                                                                   | â€¢ After the step completes, Docker **commits** the container's state as a new **image layer**.                                                                                                                   |
|                                                                   | â€¢ The `Container` field records the **ID of the temporary container** used for that layer.                                                                                                                       |
|                                                                   | â€¢ The `ContainerConfig` field stores the **configuration** of that container (env vars, command, working directory, etc.).                                                                                       |
|                                                                   | â€¢ These fields are **only used internally** during the build process â€” they donâ€™t affect `docker run`.                                                                                                           |
|                                                                   | âœ… **Example**: `"Cmd": ["/bin/sh", "-c", "#(nop) CMD [\"sleep\", \"36000\"]"]` is stored in `ContainerConfig` to show what command created the layer.         
|
| **What happens behind the scenes?**                               | â€¢ Docker follows a **step-by-step process** when building images from a Dockerfile.                                                                                                                              |
|                                                                   | â€¢ Steps performed for each instruction:<br>Â Â 1. Parse the instruction<br>Â Â 2. Create a temporary container from the current image<br>Â Â 3. Execute the instruction<br>Â Â 4. Commit the result as a new image layer |
|                                                                   | â€¢ Docker records metadata for each layer:<br>Â Â â€¢ Container ID<br>Â Â â€¢ Parent image ID<br>Â Â â€¢ Commands used<br>Â Â â€¢ Container config                                                                                |
|                                                                   | â€¢ Each new image layer is **built upon the previous one**, forming a chain of layers.                                                                                                                            |
|                                                                   | âœ… **Analogy**: Like Git commits â€” each layer builds on the one before. The final image only knows its **immediate parent**, not the full history.                                                                |

*** if we use docker commit of running container then details (parent, container and container config0) will be reflected with real values. 

---------------------
---------------------
ğŸ“ /var/lib/docker/image â€“ Overview
---------------------
---------------------

âœ… Purpose:

The /var/lib/docker/image directory is where Docker stores metadata about images, not the imagesâ€™ content itself.

This is engine-level metadata, including:

Image manifests

Image configuration (e.g., CMD, ENV, entrypoint)

Mappings of image IDs to layers

History info (for docker history)

References to content stored by the storage driver (like overlay2)

---
ğŸ“‚ Directory Structure (Common Layout)
---

/var/lib/docker/image/overlay2/
â”œâ”€â”€ imagedb/                             # Stores image configs and metadata
â”‚   â”œâ”€â”€ content/
â”‚   â”‚   â””â”€â”€ sha256/
â”‚   â”‚       â””â”€â”€ <image-config-digest>.json   # Raw image configuration (JSON)
â”‚   â”œâ”€â”€ metadata/
â”‚   â”‚   â””â”€â”€ <image-digest>.json              # Metadata linking image to layers
â”‚   â””â”€â”€ repositories.json (legacy)           # Legacy image â†’ layer mapping
â”‚
â”œâ”€â”€ layerdb/                             # Layer dependency and mapping data
â”‚   â””â”€â”€ sha256/
â”‚       â””â”€â”€ <layer-id>/
â”‚           â”œâ”€â”€ diff                        # Diff ID of the uncompressed layer
â”‚           â”œâ”€â”€ parent                      # Parent layer ID (if any)
â”‚           â”œâ”€â”€ size                        # Layer size in bytes
â”‚           â”œâ”€â”€ cache-id                    # Maps to /var/lib/docker/overlay2/<id>
â”‚           â”œâ”€â”€ tar-split.json.gz           # Optional optimized tar layer info
â”‚           â””â”€â”€ ...
â”‚
â”œâ”€â”€ distribution/                       # Metadata related to registry content
â”‚   â”œâ”€â”€ diffid-by-digest/
â”‚   â”‚   â””â”€â”€ sha256:<digest>                # Maps registry digest â†’ local diff ID
â”‚   â”‚
â”‚   â””â”€â”€ v2metadata-by-diffid/
â”‚       â””â”€â”€ sha256:<diff-id>               # JSON metadata per layer from registry
â”‚
â””â”€â”€ repositories.json                    # Legacy image index (used less now)



---
ğŸ” Breakdown of Important Subdirectories
---

1ï¸âƒ£ imagedb/ â€” The Image Database

ğŸ“Œ Purpose:

Stores Docker image configuration metadata â€” JSON blobs that describe the image's properties, Dockerfile instructions, environment, and layer relationships.

It stores:

Image IDs seen in docker images and docker image inspect

Image history metadata (the docker history output maps here)

ğŸ“‚ Key subfolders:

| Subfolder          | Content & Role                                                                                                                                                                                                                                   |
| ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `content/sha256/`  | Stores JSON blobs of **image configurations** keyed by SHA256 hash. Each file contains: <br>â€¢ OS & architecture <br>â€¢ `Cmd`, `Entrypoint`, `Env`, `Labels` <br>â€¢ `history` of Dockerfile steps <br>â€¢ `rootfs.diff_ids` (which link to `layerdb`) |
| `metadata/sha256/` | Internal Docker metadata about image configs â€” includes timestamps, references, and linkage for Dockerâ€™s bookkeeping. Not shown in CLI but used by Docker internally.                                                                            |

2ï¸âƒ£ layerdb/ â€” The Layer Database

ğŸ“Œ Purpose:

Tracks metadata for all filesystem layers in your local Docker engine â€” how they relate to one another, their diff IDs, and runtime mounts.

This is where Docker maps rootfs layers that you see in docker image inspect.

ğŸ“‚ Key subfolders/files:

| Subfolder/File | Content & Role                                                                                                                                                                                                                        |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `sha256/`      | One folder per layer (`sha256:<diffid>`). Contains: <br>â€¢ `diff` file: diff ID <br>â€¢ `cache-id` file: link to overlay2/aufs ID <br>â€¢ `parent` file: parent layer <br>â€¢ `size` file: layer size <br>â€¢ `committed` (if layer finalized) |
| `diff/`        | Symlinks or references to actual diff content (uncompressed layer). Used by storage driver.                                                                                                                                           |
| `mounts/`      | Active mount metadata (used when containers or images are running or being built).                                                                                                                                                    |

3ï¸âƒ£ distribution/ â€” Digest â†” DiffID Mapping for Registry Operations

ğŸ“Œ Purpose:

Tracks mappings between registry digests (compressed layer hashes) and local diff IDs (uncompressed content). Critical for push/pull operations, deduplication, and content verification.

ğŸ“‚ Key subfolders:

| Subfolder               | Content & Role                                                                                                    |
| ----------------------- | ----------------------------------------------------------------------------------------------------------------- |
| `diffid-by-digest/`     | Maps registry **digest** (from Docker Hub or private registries) â†’ local **diff ID** (used by Docker's `layerdb`) |
| `v2metadata-by-diffid/` | Maps **local diff ID** â†’ metadata used for pushing (mediaType, registry digest, source repository, etc)           |

ğŸ” Example Mapping Flow:

Registry Layer Digest (compressed) â”€â–º diffid-by-digest â”€â–º Local diff ID (uncompressed)
Local diff ID â”€â–º v2metadata-by-diffid â”€â–º Registry + mediaType info (for push)


4ï¸âƒ£ repositories.json â€” Local Name/Tag Mapping

ğŸ“Œ Purpose:
Stores a mapping between human-friendly image names (tags) and internal image IDs (config blob hashes).

This is what powers:

docker images

docker rmi image:tag

docker inspect image:tag

ğŸ“„ Example:

{
  "Repositories": {
    "ubuntu": {
      "ubuntu:latest": "sha256:97bed23a34971024aa8...",
      "ubuntu@sha256:66460d55...": "sha256:97bed23a34971024aa8..."
    },
    "app": {
      "app:v1": "sha256:f5f729a837f4be57..."
    }
  }
}

| Entry                 | Meaning                                                                  |
| --------------------- | ------------------------------------------------------------------------ |
| `"ubuntu:latest"`     | Tag used locally â€” maps to image config ID                               |
| `"ubuntu@sha256:...`" | Digest-based reference (immutable) â€” also maps to same image config      |
| `"sha256:<hash>"`     | The actual **image config ID** stored in `imagedb/content/sha256/<hash>` |


ğŸ”„ How They All Connect

| Component         | Maps to / Used By                | Description / Role                                                      |
| ----------------- | -------------------------------- | ----------------------------------------------------------------------- |
| `docker image ID` | `imagedb/content/sha256/`        | Stores image config JSON (metadata, env, diff IDs, etc.)                |
| `rootfs.diff_ids` | `layerdb/sha256/`                | Stores actual filesystem changes (layers), their parents, and cache IDs |
| Registry digest   | `distribution/diffid-by-digest/` | Maps registry's compressed digest â†’ local uncompressed diff ID          |
| Diff ID           | `distribution/v2metadata-.../`   | Maps local layer â†’ registry metadata (source, mediaType, etc.)          |
| Image tag         | `repositories.json`              | Maps image name/tag/digest â†’ image config ID (used in CLI)              |



----------------------------
----------------------------
GRAPH DRIVER
----------------------------
----------------------------

1ï¸âƒ£ Union Filesystem (UnionFS) â€” The Foundational Concept

What: A general filesystem concept that allows multiple directories or filesystems to be combined (stacked) and presented as one.

Role: Enables layering of filesystems, supporting copy-on-write and union of different layers.

Examples:

i) AUFS (Advanced UnionFS)

ii) OverlayFS (Linux kernel implementation)

iii) Other union filesystems (UnionFS proper, MergerFS, etc.)

---

2ï¸âƒ£ OverlayFS (Overlay Driver) â€” Kernel-Level Implementation

What: A Linux kernel feature that implements a UnionFS-type filesystem.

Role: Enables stacking multiple lower directories (layers) plus an upper writable layer, and merges them transparently.

Significance:

i) Provides the copy-on-write filesystem capabilities Docker needs to efficiently manage layered filesystems.

ii) Overlay2 Docker storage driver uses OverlayFS.

Note: OverlayFS is a type of UnionFS, but implemented inside the Linux kernel.

---

3ï¸âƒ£ Storage Driver / Graph Driver â€” Dockerâ€™s Storage Abstraction

What: Dockerâ€™s internal component that uses kernel features like OverlayFS (or AUFS, device mapper, etc.) to implement image and container filesystem layering.

Role:

i) Handles storing image layers and container writable layers.

ii) Manages copy-on-write, layer merging, and layer reuse.

Terminology:

Graph Driver and Storage Driver terms are mostly interchangeable in Docker context.

Example: Overlay2 storage/graph driver uses OverlayFS underneath.

---

4ï¸âƒ£ Docker Image & Container Layering â€” Using the Storage/Graph Driver

What: Docker builds images and containers using the storage/graph driver.

Role:

i) Layers in Docker images correspond to filesystem layers managed by storage/graph driver.

ii) Containers get a writable upper layer on top of the imageâ€™s read-only layers.

How it works:

Image layers â†’ stored as read-only layers (LowerDir)

Container writable layer â†’ UpperDir

Combined into MergedDir exposed inside container.

| Term             | Meaning Today                                 | Where You See It                |
| ---------------- | --------------------------------------------- | ------------------------------- |
| `GraphDriver`    | ğŸ”¸ Legacy name for Dockerâ€™s storage interface | `docker inspect` JSON field     |
| `Storage Driver` | ğŸ”¹ Modern, correct term for that component    | Docs, tutorials, configuration  |
| `overlay2`       | âœ… Actual driver in use                        | `docker info`, `docker inspect` |


âœ… 1. What is GraphDriver in Docker?

In Docker, the GraphDriver is part of the Storage Driver system â€” it tells Docker how container layers are stored and managed on disk.

When you run:

docker image inspect <image-id>

You get a JSON output that includes:

"GraphDriver": {
  "Name": "overlay2",
  "Data": {
    ...
  }
}


Name: This is the Storage Driver used. Most modern systems use overlay2.

Data: This gives low-level details about the image/container filesystem layers managed by the driver.

---
âœ… 2. What is overlay2? (Theory + Visual Explanation)

overlay2 is Docker's default storage driver on most Linux distributions.

Think of overlay2 like a layered cake ğŸ°:

Each Docker image has multiple read-only layers, and when you run a container, Docker adds a read-write layer on top. overlay2 is responsible for stacking these layers efficiently using the Linux overlayfs filesystem.

Hereâ€™s a simplified view:

Container Filesystem
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ RW Layer     â”‚  <-- UpperDir
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Image Layer3 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Image Layer2 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Image Layer1 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  <-- LowerDir

---
âœ… 3. Explanation of Each Field in GraphDriver.Data

Hereâ€™s your sample:

"GraphDriver": {
    "Data": {
        "LowerDir": ".../diff:.../diff:.../diff",
        "MergedDir": ".../merged",
        "UpperDir": ".../diff",
        "WorkDir": ".../work"
    }
}

---

ğŸ”¹ LowerDir

Contains read-only layers of the Docker image.

Itâ€™s a colon-separated list of directories â€” each represents a layer.

These are shared across containers created from the same image.

ğŸ” Example:

LowerDir=/var/lib/docker/overlay2/layer1/diff:/layer2/diff:/layer3/diff

This is like the â€œhistoryâ€ of the image â€” base layers.

---
ğŸ”¹ UpperDir

This is the read-write layer for the current container.

Any file modifications, additions, or deletions go here.

ğŸ” Example:

UpperDir=/var/lib/docker/overlay2/container-layer-id/diff

Only this container can access or write here.

---
ğŸ”¸ WorkDir

A working directory used internally by the overlay filesystem to manage operations (e.g., copying files during writes).

Itâ€™s required for overlay2 to function but not something you directly interact with.

ğŸ§  Think of it as a temporary workspace used by the kernel when managing writes to UpperDir.

---
ğŸ”¸ MergedDir

This is the final mount point where all the layers (Lower + Upper) are combined.

When you docker exec into a container, you are inside this merged view.

âœ… Example:

If a file exists in a lower layer and you modify it, the updated copy appears in MergedDir via UpperDir.

| Path        | Purpose                        | What's Inside?                              |
| ----------- | ------------------------------ | ------------------------------------------- |
| `LowerDir`  | Read-only image layers         | Files and dirs from base image and parents  |
| `UpperDir`  | Writable container layer       | Changes made by the container               |
| `MergedDir` | Final merged view (read/write) | What you "see" inside the running container |
| `WorkDir`   | Internal kernel space          | Used by overlay2 during copy-on-write ops   |


---
step by step process

Hereâ€™s a refined version of your â€œWhat happens during docker runâ€ sequence, with small expansions:

1) The Docker daemon verifies the image (if not present locally, pulls it).

2) A new container is created: a new writable layer (upperdir) is allocated for the container.

3) Docker identifies the imageâ€™s existing readâ€‘only layers (these become one or more lowerdir entries).

4) Docker (via the overlay2 storage driver) sets up a workdir for internal overlayfs operations.

5) The kernelâ€™s OverlayFS mounts a union filesystem combining:

i) The lowerdir (one or more image layers, readâ€‘only)

ii) The upperdir (containerâ€™s writable layer)

iii) And uses the workdir for the overlay mountâ€™s internal needs
The mount point is the merged directory, which becomes the containerâ€™s root filesystem (/).

6) The container process starts and sees the merged view as its filesystem root.

7) During container execution:

i) Reads: If file exists in upperdir â†’ use it; else â†’ search lowerdir.

ii) Writes/Modifications: If modifying a file existing in lowerdir, then the file is first â€œcopied upâ€ into upperdir (copyâ€‘onâ€‘write) and then modifications occur there.

iii) Deletes: Deletions from the container result in whiteout files/opaque directories in upperdir which hide the original file/directory in the lowerdir.

iv) Upperdir continues to accumulate changes for that container; the lowerdir remains unchanged (shared among containers/images).

8) When the container stops and is removed, its writable layer (upperdir) is removed; underlying image layers remain.