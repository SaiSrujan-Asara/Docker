üß± 1Ô∏è‚É£ What is docker run?

docker run is the primary command to create and start a new container from a Docker image.

Think of it like this:

docker run = create + start + (optionally) attach + (optionally) remove container

Whenever you execute:

docker run <image>

Docker will:

Check if the image exists locally ‚Äî if not, it downloads it from Docker Hub (or registry).

Create a writable container layer on top of that image.

Assign it a container ID (and name if not given).

Start the main process inside the container.

Optionally attach your terminal to that container (interactive mode).

---
üöÄ 2Ô∏è‚É£ Basic Syntax

docker run [OPTIONS] IMAGE [COMMAND] [ARG...]

IMAGE ‚Üí name of the Docker image (like ubuntu, nginx, alpine, etc.)

COMMAND ‚Üí optional command to run inside the container (overrides the default CMD in the Dockerfile)

OPTIONS ‚Üí flags to modify behavior (like -d, -p, --name, etc.)

---
üß© 3Ô∏è‚É£ Basic Examples

Example 1 ‚Äî Run a simple Ubuntu container

docker run ubuntu

Pulls the latest Ubuntu image if not present.

Creates a container and runs the default command (bash in many cases).

Exits immediately if no interactive terminal is attached.

--
Example 2 ‚Äî Run interactively (keep terminal open)

docker run -it ubuntu

-i: interactive (keeps STDIN open)

-t: allocates a pseudo-TTY

You‚Äôll be dropped into a shell inside the container:

root@container_id:/#

--
Example 3 ‚Äî Run in detached mode (background)

docker run -d nginx

-d: detached mode (runs in background)

The container runs Nginx server in the background.

Returns the container ID.

You can check it using:

docker ps

--
Example 4 ‚Äî Run and expose a port

docker run -d -p 8080:80 nginx

-p host_port:container_port

Maps port 8080 on your host to 80 inside the container.

Access in browser ‚Üí http://localhost:8080

--
Example 5 ‚Äî Run with a specific name

docker run -d --name webserver nginx

--name assigns a human-readable name to the container.

--
Example 6 ‚Äî Run and remove automatically when stopped

docker run --rm ubuntu echo "Hello Docker!"

--rm: Automatically removes the container after it exits.

Useful for short-lived tasks.

---
üß† 4Ô∏è‚É£ How docker run actually works internally

Internally, docker run performs several steps:

Pull image ‚Üí if not found locally.

Create container ‚Üí like docker create.

Allocate resources ‚Üí network, volume, filesystem, etc.

Start container ‚Üí same as docker start.

Attach (optional) ‚Üí connect your terminal if requested.

Equivalent command breakdown:

docker pull ubuntu
docker create ubuntu
docker start -a -i <container_id>

So docker run is basically a shorthand for all the above steps combined.

---
üß© 5Ô∏è‚É£ Most Commonly Used Options (with Examples)

| Option          | Description                            | Example                                          |
| --------------- | -------------------------------------- | ------------------------------------------------ |
| `-d`            | Detached mode (background)             | `docker run -d nginx`                            |
| `-it`           | Interactive + TTY                      | `docker run -it ubuntu bash`                     |
| `--name`        | Assign a custom container name         | `docker run --name myapp alpine`                 |
| `--rm`          | Remove container when it exits         | `docker run --rm ubuntu echo hi`                 |
| `-p`            | Publish a container‚Äôs port to the host | `docker run -p 8080:80 nginx`                    |
| `-v`            | Mount a volume                         | `docker run -v /host/path:/container/path nginx` |
| `-e`            | Set environment variables              | `docker run -e VAR=value nginx`                  |
| `--env-file`    | Load env vars from file                | `docker run --env-file .env nginx`               |
| `--network`     | Connect to a specific network          | `docker run --network mynet nginx`               |
| `--entrypoint`  | Override default entrypoint            | `docker run --entrypoint /bin/bash ubuntu`       |
| `--restart`     | Restart policy                         | `docker run --restart always nginx`              |
| `--cpus`        | Limit CPU usage                        | `docker run --cpus="1.5" nginx`                  |
| `--memory`      | Limit memory usage                     | `docker run --memory="500m" nginx`               |
| `--detach-keys` | Override detach key sequence           | `docker run --detach-keys="ctrl-x,x" nginx`      |

---
‚öôÔ∏è 8Ô∏è‚É£ Best Practices for docker run

‚úÖ Always use --name for readability.
‚úÖ Use --rm for short-lived containers.
‚úÖ Limit resources using --cpus and --memory.
‚úÖ Avoid running containers as root unless necessary.
‚úÖ Use -d for services and -it for debugging.
‚úÖ Map only necessary ports (-p).
‚úÖ For persistent data, use -v or named volumes instead of host paths.
‚úÖ Store credentials via --env-file, not directly in command line.
‚úÖ Use versioned images (nginx:1.25, not nginx:latest) for stability.

----------------------------
üß± Understanding -i, -t, -d in docker run
----------------------------

These three options control how your terminal interacts with the container process.

‚öôÔ∏è 1Ô∏è‚É£ -i ‚Üí Interactive

Meaning:

Keeps STDIN (standard input) open, even if not attached.

It tells Docker:

‚ÄúKeep the container‚Äôs input stream open ‚Äî I might type something into it.‚Äù

Example:

docker run -i ubuntu

Container runs, and STDIN remains open.

But no terminal interface (no colors, prompts, etc.) ‚Äî just raw input/output.

üß† Think: You can type into the container, but you‚Äôre blind ‚Äî no proper terminal view.

Use Case:

When you want to pipe data into the container or run non-interactive scripts.

Example:

cat script.sh | docker run -i ubuntu bash

Here, you‚Äôre sending script input into the container.

---
üñ•Ô∏è 2Ô∏è‚É£ -t ‚Üí TTY (pseudo-terminal)

Meaning:

Allocates a pseudo-TTY (a terminal interface like what you see in your shell).

It makes Docker act like a normal Linux terminal ‚Äî it handles line breaks, colors, control keys, etc.

Example:

docker run -t ubuntu

Starts a container with a terminal-like interface.

If you run docker run -t ubuntu without -i, the container can keep running (the shell /bin/bash is in the foreground), but you cannot interact with it from the terminal because STDIN is not attached.

Output:

root@140846dd9f49:/# ls

üß† Think: You have a terminal, but you can‚Äôt type into it (input closed).

Use Case:

Rarely used alone.

Used mostly in combination with -i.

---
üß© 3Ô∏è‚É£ -it ‚Üí Interactive + Terminal (most common)

Meaning:

Combines both ‚Äî keeps STDIN open and allocates a pseudo-terminal.

Example:

docker run -it ubuntu

You get a fully interactive shell inside the container (with prompt and color).

The session looks and feels like a normal Linux terminal.

Output:

root@a1b2c3d4:/#

You can run commands like:

apt update
ls /
echo "Hello"

üí° This is the most common combination for exploring or debugging containers.

---
‚öôÔ∏è 4Ô∏è‚É£ -d ‚Üí Detached mode (background)

Meaning:

Runs the container in the background, without attaching your terminal.

You immediately get back the container ID:

docker run -d nginx

The container continues running in the background, and you can view it via:

docker ps

You can reattach later using:

docker attach <container_id>

or

docker exec -it <container_id> bash

üí° Typical for running services like web servers, databases, message brokers, etc.

---
üîç 5Ô∏è‚É£ Combinations and When to Use Each

| Command                                | Behavior                                                     | Typical Use Case                                         |
| -------------------------------------- | ------------------------------------------------------------ | -------------------------------------------------------- |
| `docker run ubuntu`                    | Runs container, exits immediately (no TTY or input open)     | Used rarely; mostly for containers that finish instantly |
| `docker run -i ubuntu`                 | STDIN open, but no TTY                                       | When piping data to container                            |
| `docker run -t ubuntu`                 | Has terminal, but no open input ‚Üí exits                      | Rarely used                                              |
| `docker run -it ubuntu`                | Interactive shell, full terminal                             | Debugging, exploration, manual testing                   |
| `docker run -d ubuntu`                 | Detached mode, background                                    | Long-running services                                    |
| `docker run -dit ubuntu`               | Detached + interactive shell (runs in background with a TTY) | Start container with TTY for later attach                |
| `docker run -dit --name mytest ubuntu` | Run Ubuntu in background but allow later attach              | For keeping debugging containers running persistently    |

--
üß† 6Ô∏è‚É£ Real-World Examples

üß© Case 1 ‚Äî Debugging or exploring container manually

docker run -it ubuntu

‚Üí You want to interact with it, run commands, test scripts.
--
üß© Case 2 ‚Äî Running a web server

docker run -d -p 8080:80 nginx

‚Üí You don‚Äôt need to see terminal logs; runs in background.

--
üß© Case 3 ‚Äî Want to start container detached but keep ability to attach later

docker run -dit --name debugbox ubuntu

‚Üí Start container silently, and attach anytime with:

docker attach debugbox

--
üß© Case 4 ‚Äî Pipe input data

cat data.txt | docker run -i ubuntu cat

‚Üí Input data from file is piped into container.

---
üß± 1Ô∏è‚É£ Understanding Docker flag parsing

Docker (and most Linux CLI tools) treats multiple single-letter flags combined in any order as equivalent to specifying them individually.

docker run -di is the same as docker run -id
docker run -dt is the same as docker run -td

So flag order doesn‚Äôt matter; Docker just parses each character.

--
‚öôÔ∏è 2Ô∏è‚É£ Breaking Down -di (-d -i)

Meaning:

-d ‚Üí detached mode (run container in background)

-i ‚Üí keep STDIN open

Behavior:

docker run -di ubuntu

Starts container in background (-d).

Keeps STDIN open (-i), meaning you could theoretically attach to the container later and have interactive input.

No TTY allocated, because -t is missing.

Example:

docker run -di --name test1 ubuntu tail -f /dev/null

tail -f /dev/null keeps the container running indefinitely.

Container runs in background.

You can attach input later using:

docker attach test1

But without -t, your terminal behaves weirdly ‚Äî no proper prompts, colors, or line-editing. Input works but looks ‚Äúraw.‚Äù

üí° Key point: -di is useful if you want a background container that keeps STDIN open for programmatic input, but not for interactive shell exploration.

--
‚öôÔ∏è 3Ô∏è‚É£ Breaking Down -dt (-d -t)

Meaning:

-d ‚Üí detached mode

-t ‚Üí allocate a TTY

Behavior:

docker run -dt ubuntu

Starts container in background (-d).

Allocates pseudo-terminal (-t) ‚Üí makes process think it has a terminal.

STDIN is not open because -i is missing.

Example:

docker run -dt --name test2 ubuntu bash

Container runs in background.

TTY is allocated, so processes that require a terminal won‚Äôt fail.

But you cannot type input directly, because STDIN is closed.

To get a proper shell later, you would still use:

docker exec -it test2 bash

üí° Key point: -dt is useful when running background containers that need a terminal for processes (some programs fail if TTY is missing), but you don‚Äôt need STDIN open.

---
‚ö° 4Ô∏è‚É£ Comparison Table of Less Common Combinations

| Flags  | Behavior                      | Use Case                                                                                                           |
| ------ | ----------------------------- | ------------------------------------------------------------------------------------------------------------------ |
| `-di`  | Background + keep STDIN open  | Background container that may receive piped input later                                                            |
| `-dt`  | Background + TTY allocated    | Run a background process that needs a TTY (e.g., interactive tools like top, bash, or programs expecting terminal) |
| `-dit` | Background + TTY + STDIN open | Fully interactive background container (attach later to work interactively)                                        |

--
üß© 5Ô∏è‚É£ Real Examples

5.1 -di

docker run -di --name di_example ubuntu tail -f /dev/null

docker attach di_example

Container runs in background.

You attach input later.

No TTY ‚Üí shell looks raw, minimal editing capabilities.

--
5.2 -dt

docker run -dt --name dt_example ubuntu top

docker logs dt_example

Container runs background top command.

TTY exists ‚Üí top works without errors.

Cannot interact with it via input directly (STDIN closed).

--
5.3 -dit (for completeness)

docker run -dit --name dit_example ubuntu bash

docker attach dit_example

Fully interactive background container.

You can attach anytime and get proper shell with TTY and input.

------------------------
------------------------
üîπ Core Concept: Main Process Determines Container Life
------------------------
------------------------

In Docker:

Every container runs a single main process (PID 1).

The container stays alive as long as that process runs.

Flags like -i, -t, or -d do not change whether the container stays alive; they only affect how you interact with the container.

1Ô∏è‚É£ Foreground vs Background

Foreground:

docker run ubuntu tail -f /dev/null (Runs attached to your terminal (FG))

You see logs/output directly.

Pressing Ctrl+C stops the container (unless detached using -d).

Background (Detached):

docker run -d ubuntu tail -f /dev/null (Runs in background (detached).)

Container is alive in background.

Logs can be checked via docker logs <container>.

Observation:

Main process (tail -f /dev/null) is running in both cases.

Container stays alive regardless of interactive flags or foreground/background.

******* A Docker container‚Äôs lifecycle is dictated entirely by its main process. 
Flags like -i, -t, and -d only control interaction mode and terminal allocation. 
If the main process is long-running, the container will stay alive regardless of foreground or background execution. 
Short-lived processes exit immediately in both modes ******

--------

üìù Docker -i, -t, -d Combination Behavior Table with default processor (cmd /bin/bash) using ubuntu image (****If we use default running processor of image such as bash or shell*****)

****** if Main process is running fine then there is no effect in running in foreground or backgrond without limitation of any parameter we use in running container*******

| Flags Combination          | Runs in FG/BG | Container Status (Default command `/bin/bash`)                                     | Reason / Explanation                                                                  | Interview Tip                                                                           |
| -------------------------- | ------------- | ---------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------- |
| None (`docker run ubuntu`) | Foreground    | Exited immediately                                                                 | No TTY, no STDIN ‚Üí bash exits instantly                                               | Default behavior; container needs a running main process                                |
| `-i`                       | Foreground    | Exited on Ctrl+D; alive if restarted                                               | STDIN open ‚Üí bash stays waiting for input. If input closes, process exits             | Useful for programmatic input; rarely used alone for interactive shell                  |
| `-t`                       | Foreground    | Exited                                                                             | TTY allocated but no input ‚Üí bash finds no input, exits                               | TTY alone doesn‚Äôt keep container alive; usually combined with `-i`                      |
| `-it`                      | Foreground    | Alive while attached; exits on `exit`; background possible via `Ctrl+P Ctrl+Q`     | STDIN open + TTY ‚Üí interactive shell works properly                                   | Standard way for interactive exploration; detach without stopping using `Ctrl+P Ctrl+Q` |
| `-d`                       | Background    | Exited immediately                                                                 | Detached mode alone ‚Üí bash runs, exits immediately because main process finishes      | Detached mode requires long-running process to stay alive                               |
| `-di`                      | Background    | Alive if main process is long-running (`tail -f /dev/null` or bash)                | Detached + STDIN open ‚Üí container can stay alive; process must not finish immediately | Useful for background containers expecting input later                                  |
| `-dt`                      | Background    | Alive if main process is long-running (`top` or bash)                              | Detached + TTY ‚Üí some programs require terminal; without it, may fail                 | TTY ensures processes that need terminal don‚Äôt crash in background                      |
| `-dit`                     | Background    | Alive; fully attachable anytime                                                    | Detached + STDIN open + TTY ‚Üí fully interactive background container                  | Best practice for debugging or interactive background containers                        |

Flags           | Behavior                         | Use Case
----------------|---------------------------------|----------------------------------
none            | Exits immediately               | Default behavior
-i              | Waits for input                  | Programmatic input
-t              | Exits if no input                | TTY allocation only
-it             | Interactive shell                | Explore container interactively
-d              | Exits unless long-running proc   | Background process must be long-running
-di             | Background + STDIN open          | Background with possible input
-dt             | Background + TTY                 | Background programs requiring terminal
-dit            | Background + TTY + STDIN         | Full interactive background container

---
‚ö° 8Ô∏è‚É£ Advanced Tip: Attaching / Detaching Controls

When you run a container interactively (-it), you can detach from it without stopping it.

üëâ Default detach keys: Ctrl + P then Ctrl + Q

This keeps the container running in background.

You can later reattach using:

docker attach <container_name>

If you want to change the detach key sequence (say you use tmux or vim), use:

docker run -it --detach-keys="ctrl-x,x" ubuntu

---
üß∞ 9Ô∏è‚É£ Example: Combining -it and -d with docker exec

Sometimes you want to:

Run a container in background.

Then open a shell inside it later.

Example:

docker run -d --name web nginx
docker exec -it web bash

Here:

docker run -d ‚Üí starts background service.

docker exec -it ‚Üí attaches a new interactive shell to inspect or debug.

This is preferred over running docker run -dit for long-term containers.

---
üèÅ 10Ô∏è‚É£ Interview-Level Insights

üß© Q: Why does docker run -t ubuntu exit immediately?

A: Because there‚Äôs no open STDIN (-i missing), so the container has no input to keep running ‚Äî the process ends instantly.

üß© Q: What‚Äôs difference between -it and -dit?

A: -it: Runs interactively in foreground.

   -dit: Runs interactively but detached in background (can attach later).

üß© Q: If you run docker run -it ubuntu and press Ctrl+C ‚Äî what happens?

A: It stops the container because Ctrl+C sends SIGINT to the container‚Äôs main process.

üß© Q: What happens when you detach using Ctrl+P Ctrl+Q?

A: The container continues running in background.

‚úÖ 11Ô∏è‚É£ Best Practices Summary

| Goal                                                   | Best Option                        |
| ------------------------------------------------------ | ---------------------------------- |
| Run service / app in background                        | `-d`                               |
| Run interactive shell                                  | `-it`                              |
| Start container in background but want to attach later | `-dit`                             |
| Pipe data into container                               | `-i` only                          |
| Debug running container                                | `docker exec -it <container> bash` |
| Prevent accidental container stop when detaching       | Use `Ctrl+P Ctrl+Q`                |


--------------------------
--------------------------
PARAMETERS USED IN CONTAINER RUN
--------------------------
--------------------------

| Environment        | Main Focus                                        |
| ------------------ | ------------------------------------------------- |
| üßë‚Äçüíª Development  | Flexibility, interactivity, code mounting         |
| üß™ Testing         | Ephemeral containers, automation, reproducibility |
| üè≠ Production      | Stability, security, observability                |
| üîç Troubleshooting | Debugging, introspection, temporary access        |


üßë‚Äçüíª 1Ô∏è‚É£ Development Environment Parameters

| Parameter      | Example                                | Purpose                                          |
| -------------- | -------------------------------------- | ------------------------------------------------ |
| `-it`          | `docker container run -it ubuntu bash` | Interactive shell for dev/debug                  |
| `--name`       | `--name web-dev`                       | Easy container identification                    |
| `-v`           | `-v $(pwd):/app`                       | Mount local source code for live editing         |
| `-p`           | `-p 3000:3000`                         | Map container app port to host                   |
| `--rm`         | `--rm`                                 | Auto-remove when stopped (avoid clutter)         |
| `-e`           | `-e ENV=dev -e DEBUG=true`             | Inject dev environment variables                 |
| `--workdir`    | `--workdir /app`                       | Set working directory inside container           |
| `--network`    | `--network dev_net`                    | Connect to local dev network                     |
| `--entrypoint` | `--entrypoint bash`                    | Override default entrypoint for debugging        |
| `-u`           | `-u $(id -u):$(id -g)`                 | Run as host user to avoid file permission issues |


üß© Example ‚Äî Full Dev Command

docker container run -it --rm \
  --name node-dev \
  -v $(pwd):/usr/src/app \
  -w /usr/src/app \
  -p 3000:3000 \
  -e NODE_ENV=development \
  node:18 bash


üß™ 2Ô∏è‚É£ Testing / CI/CD Environment Parameters

| Parameter       | Example                   | Purpose                                      |
| --------------- | ------------------------- | -------------------------------------------- |
| `--rm`          | `docker run --rm`         | Automatically clean up after test run        |
| `-v`            | `-v $(pwd):/tests`        | Mount test directory or artifacts            |
| `-e`            | `-e TEST_ENV=ci`          | Pass environment-specific configs            |
| `--network`     | `--network test_net`      | Connect test containers                      |
| `--name`        | `--name pytest-container` | Easier log tracking in CI                    |
| `--entrypoint`  | `--entrypoint pytest`     | Override to run test runner directly         |
| `-u`            | `-u root`                 | Sometimes needed for CI tools to write files |
| `-w`            | `-w /tests`               | Set working directory for commands           |
| `--pull always` | `--pull always`           | Always fetch latest image for CI consistency |

docker container run --rm \
  --name python-tests \
  -v $(pwd):/tests \
  -w /tests \
  -e TEST_ENV=ci \
  --pull always \
  python:3.12 pytest -v


üè≠ 3Ô∏è‚É£ Production Environment Parameters

| Parameter        | Example                                                                   | Purpose                                    |          |                               |
| ---------------- | ------------------------------------------------------------------------- | ------------------------------------------ | -------- | ----------------------------- |
| `-d`             | `-d`                                                                      | Run container in background                |          |                               |
| `--name`         | `--name api-service`                                                      | Consistent naming for monitoring           |          |                               |
| `--restart`      | `--restart=always`                                                        | Auto-restart on crash or system reboot     |          |                               |
| `-p`             | `-p 80:80`                                                                | Expose application ports                   |          |                               |
| `-v`             | `-v app_data:/var/lib/app`                                                | Persist application data                   |          |                               |
| `--env-file`     | `--env-file .env`                                                         | Load many env vars securely                |          |                               |
| `--log-driver`   | `--log-driver=json-file`                                                  | Configure logging behavior                 |          |                               |
| `--log-opt`      | `--log-opt max-size=10m --log-opt max-file=3`                             | Limit log size and rotation                |          |                               |
| `--health-cmd`   | `--health-cmd="curl -f [http://localhost/health](http://localhost/health) |                                            | exit 1"` | Define container health check |
| `--memory`       | `--memory=512m`                                                           | Limit memory usage                         |          |                               |
| `--cpus`         | `--cpus=1.0`                                                              | Limit CPU usage                            |          |                               |
| `--security-opt` | `--security-opt=no-new-privileges`                                        | Harden container                           |          |                               |
| `--user`         | `--user 1000`                                                             | Drop root privileges                       |          |                               |
| `--read-only`    | `--read-only`                                                             | Mount filesystem as read-only for security |          |                               |
| `--cap-drop`     | `--cap-drop=ALL`                                                          | Remove all unnecessary Linux capabilities  |          |                               |

docker container run -d \
  --name web-app \
  -p 443:443 \
  --restart=always \
  -v app_logs:/var/log/nginx \
  -v app_data:/usr/share/nginx/html \
  --env-file /etc/app/config.env \
  --memory=512m \
  --cpus=1.5 \
  --security-opt=no-new-privileges \
  --read-only \
  --health-cmd="curl -f http://localhost/health || exit 1" \
  nginx:1.25-alpine


üîç 4Ô∏è‚É£ Troubleshooting / Debugging Environment Parameters

| Parameter                                      | Example                                   | Purpose                                               |
| ---------------------------------------------- | ----------------------------------------- | ----------------------------------------------------- |
| `-it`                                          | `-it`                                     | Get interactive terminal access                       |
| `--rm`                                         | `--rm`                                    | Auto-remove after debugging                           |
| `--entrypoint`                                 | `--entrypoint bash`                       | Override entrypoint for manual debugging              |
| `--network container:<id>`                     | `--network container:web-app`             | Attach to same network namespace as another container |
| `-v /var/run/docker.sock:/var/run/docker.sock` | Mount Docker socket for admin/debug tasks |                                                       |
| `--privileged`                                 | `--privileged`                            | Gives full privileges (for low-level debugging only)  |
| `-e`                                           | `-e DEBUG=true`                           | Enable verbose/debug modes                            |
| `--pid host`                                   | `--pid host`                              | View host processes (for diagnosing PID issues)       |
| `--cap-add`                                    | `--cap-add=SYS_PTRACE`                    | Needed for debugging tools (e.g., `strace`, `gdb`)    |


docker container run -it --rm \
  --name debug-tools \
  --network container:web-app \
  --cap-add=SYS_PTRACE \
  --entrypoint bash \
  alpine:latest


üß≠ Best Practices Summary

‚úÖ Use --rm for short-lived and test containers
‚úÖ Use --restart policies in production
‚úÖ Use --env-file instead of -e for production secrets
‚úÖ Use --memory & --cpus for resource control
‚úÖ Use --health-cmd for observability
‚úÖ Avoid --privileged in production ‚Äî too risky
‚úÖ Always use specific image versions, not latest

------------------
------------------
run multiple commands sequentially or conditionally
------------------
------------------

‚úÖ 1. Using Shell (sh -c or bash -c)

The easiest way to run multiple commands is to invoke a shell and pass a string of commands.

Syntax

docker run <image> sh -c "command1; command2; command3"

Or if the container has bash:

docker run <image> bash -c "command1; command2; command3"

; ‚Üí execute commands sequentially, regardless of success/failure

&& ‚Üí execute next command only if previous succeeds

|| ‚Üí execute next command only if previous fails

---
Example 1 ‚Äî Sequential commands

docker run ubuntu sh -c "echo 'Hello'; echo 'World'"

Output:

Hello
World

---
Example 2 ‚Äî Conditional execution

docker run ubuntu sh -c "mkdir /data && echo 'Directory created'"

echo 'Directory created' runs only if mkdir /data succeeds

---
Example 3 ‚Äî Command on failure

docker run ubuntu sh -c "cd /nonexistent || echo 'Failed to cd'"

echo 'Failed to cd' runs because cd /nonexistent fails

---
‚úÖ 2. Using -c with Interactive Mode

If you want an interactive container (-it) and run multiple commands:

docker run -it ubuntu bash -c "echo 'Start'; ls /; echo 'Done'"

Output:

Start
bin  etc  home  usr  var
Done

---
‚úÖ 3. Using Script File

You can write a shell script and mount it into the container, then run it:

echo -e "#!/bin/sh\necho Hello\necho World" > script.sh
docker run -v "$PWD/script.sh:/script.sh" --rm ubuntu sh /script.sh

Mounts local script into container

Executes multiple commands as defined in script

---
‚úÖ 4. Using docker exec with chain commands (for running inside a running container)

docker exec mycontainer sh -c "echo 'Start'; ls /; echo 'Done'"

Same syntax as docker run, but runs in already running container

---
‚úÖ 5. Using &&, ;, || explained

| Operator | Behavior                               | Example                            |                                     |                  |   |              |
| -------- | -------------------------------------- | ---------------------------------- | ----------------------------------- | ---------------- | - | ------------ |
| `;`      | Always run next command                | `echo a; echo b` ‚Üí prints a then b |                                     |                  |   |              |
| `&&`     | Run next **only if previous succeeds** | `mkdir /data && echo created`      |                                     |                  |   |              |
| `        |                                        | `                                  | Run next **only if previous fails** | `cd /nonexistent |   | echo failed` |

---
‚úÖ Best Practices

Use a shell (sh -c or bash -c) to run chains in docker run

Prefer && over ; if failure should stop execution

Use scripts for long sequences, easier to maintain

Quote commands properly to avoid shell parsing issues:

docker run ubuntu sh -c "echo 'Hello World'; ls /"

---
DIFFERENCE BETWEEN "sh -c" && "bash -c"
---

‚úÖ 1. sh -c

sh = POSIX-compliant shell (usually dash or ash depending on the OS)

-c ‚Üí takes the next string as a command to execute

Syntax:

sh -c "command1; command2; command3"

Behavior

i) Lightweight shell ‚Üí almost all Linux containers have it (alpine, ubuntu)

Supports basic shell features:

i) command chaining (;, &&, ||)

ii) variables, loops (for, while)

Does NOT support Bash-specific features:

[[ ]] tests

(( )) arithmetic

Bash arrays, source command

Example

docker run alpine sh -c "echo Hello; echo World"

Output:

Hello
World

--

‚úÖ 2. bash -c

bash = GNU Bourne Again Shell ‚Üí more feature-rich

-c ‚Üí same meaning, execute string as command

Syntax:

bash -c "command1; command2; command3"

Behavior

Supports all Bash-specific features:

Arrays, [[ ]] tests

(( )) arithmetic

Bash functions, process substitution

source command (. filename)

Slightly heavier ‚Üí not always installed in minimal images (like alpine)

Example

docker run ubuntu bash -c "arr=(a b c); echo ${arr[1]}"

Output:

b

This would fail with sh -c because sh doesn‚Äôt support arrays


---------
‚úÖ 1. Docker commands where sh -c / bash -c are used

| Docker Command       | How `sh -c` / `bash -c` is used                                                                                                                                                                             | Example                                               |
| -------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------- |
| **docker run**       | Start a new container and execute multiple commands                                                                                                                                                         | `docker run ubuntu sh -c "echo Hello; echo World"`    |
| **docker exec**      | Run commands inside a **running container**                                                                                                                                                                 | `docker exec -it mycontainer sh -c "ls /; echo Done"` |
| **docker start -ai** | **Indirectly**: You cannot use `sh -c` here to run commands because `docker start -ai` only attaches to the **main process (PID 1)**. You would need to change the main process or run commands via `exec`. | N/A                                                   |

‚úÖ 2. Why you use it

sh -c / bash -c lets you pass a string of commands to the shell instead of running one single command.

This is especially useful for:

Command chaining: ;, &&, ||

Advanced shell features: loops, arrays, conditionals

Multi-command execution in a single Docker invocation

‚úÖ 3. Examples

--
i) With docker run

docker run ubuntu sh -c "echo Hello; echo World"

--
ii) With docker exec

docker exec -it mycontainer bash -c "echo Start; ls /; echo Done"

Opens a new shell process in a running container

You can chain commands or use bash-specific features

---
‚úÖ 4. Important Notes

docker start -ai attaches to the container's PID 1, so you cannot pass sh -c or bash -c here unless PID 1 is explicitly a shell.

Example: If you made the container's main process bash:

docker start -ai mycontainer

Then PID 1 is shell ‚Üí you can type commands interactively, but you‚Äôre not passing -c automatically.

docker exec is usually the preferred way to run multiple commands inside an already running container.