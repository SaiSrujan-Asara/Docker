ğŸ§± 1ï¸âƒ£ What is docker run?

docker run is the primary command to create and start a new container from a Docker image.

Think of it like this:

docker run = create + start + (optionally) attach + (optionally) remove container

Whenever you execute:

docker run <image>

Docker will:

Check if the image exists locally â€” if not, it downloads it from Docker Hub (or registry).

Create a writable container layer on top of that image.

Assign it a container ID (and name if not given).

Start the main process inside the container.

Optionally attach your terminal to that container (interactive mode).

---
ğŸš€ 2ï¸âƒ£ Basic Syntax

docker run [OPTIONS] IMAGE [COMMAND] [ARG...]

IMAGE â†’ name of the Docker image (like ubuntu, nginx, alpine, etc.)

COMMAND â†’ optional command to run inside the container (overrides the default CMD in the Dockerfile)

OPTIONS â†’ flags to modify behavior (like -d, -p, --name, etc.)

---
ğŸ§© 3ï¸âƒ£ Basic Examples

Example 1 â€” Run a simple Ubuntu container

docker run ubuntu

Pulls the latest Ubuntu image if not present.

Creates a container and runs the default command (bash in many cases).

Exits immediately if no interactive terminal is attached.

--
Example 2 â€” Run interactively (keep terminal open)

docker run -it ubuntu

-i: interactive (keeps STDIN open)

-t: allocates a pseudo-TTY

Youâ€™ll be dropped into a shell inside the container:

root@container_id:/#

--
Example 3 â€” Run in detached mode (background)

docker run -d nginx

-d: detached mode (runs in background)

The container runs Nginx server in the background.

Returns the container ID.

You can check it using:

docker ps

--
Example 4 â€” Run and expose a port

docker run -d -p 8080:80 nginx

-p host_port:container_port

Maps port 8080 on your host to 80 inside the container.

Access in browser â†’ http://localhost:8080

--
Example 5 â€” Run with a specific name

docker run -d --name webserver nginx

--name assigns a human-readable name to the container.

--
Example 6 â€” Run and remove automatically when stopped

docker run --rm ubuntu echo "Hello Docker!"

--rm: Automatically removes the container after it exits.

Useful for short-lived tasks.

---
ğŸ§  4ï¸âƒ£ How docker run actually works internally

Internally, docker run performs several steps:

Pull image â†’ if not found locally.

Create container â†’ like docker create.

Allocate resources â†’ network, volume, filesystem, etc.

Start container â†’ same as docker start.

Attach (optional) â†’ connect your terminal if requested.

Equivalent command breakdown:

docker pull ubuntu
docker create ubuntu
docker start -a -i <container_id>

So docker run is basically a shorthand for all the above steps combined.

---
ğŸ§© 5ï¸âƒ£ Most Commonly Used Options (with Examples)

| Option          | Description                            | Example                                          |
| --------------- | -------------------------------------- | ------------------------------------------------ |
| `-d`            | Detached mode (background)             | `docker run -d nginx`                            |
| `-it`           | Interactive + TTY                      | `docker run -it ubuntu bash`                     |
| `--name`        | Assign a custom container name         | `docker run --name myapp alpine`                 |
| `--rm`          | Remove container when it exits         | `docker run --rm ubuntu echo hi`                 |
| `-p`            | Publish a containerâ€™s port to the host | `docker run -p 8080:80 nginx`                    |
| `-v`            | Mount a volume                         | `docker run -v /host/path:/container/path nginx` |
| `-e`            | Set environment variables              | `docker run -e VAR=value nginx`                  |
| `--env-file`    | Load env vars from file                | `docker run --env-file .env nginx`               |
| `--network`     | Connect to a specific network          | `docker run --network mynet nginx`               |
| `--entrypoint`  | Override default entrypoint            | `docker run --entrypoint /bin/bash ubuntu`       |
| `--restart`     | Restart policy                         | `docker run --restart always nginx`              |
| `--cpus`        | Limit CPU usage                        | `docker run --cpus="1.5" nginx`                  |
| `--memory`      | Limit memory usage                     | `docker run --memory="500m" nginx`               |
| `--detach-keys` | Override detach key sequence           | `docker run --detach-keys="ctrl-x,x" nginx`      |

---
âš™ï¸ 8ï¸âƒ£ Best Practices for docker run

âœ… Always use --name for readability.
âœ… Use --rm for short-lived containers.
âœ… Limit resources using --cpus and --memory.
âœ… Avoid running containers as root unless necessary.
âœ… Use -d for services and -it for debugging.
âœ… Map only necessary ports (-p).
âœ… For persistent data, use -v or named volumes instead of host paths.
âœ… Store credentials via --env-file, not directly in command line.
âœ… Use versioned images (nginx:1.25, not nginx:latest) for stability.

----------------------------
ğŸ§± Understanding -i, -t, -d in docker run
----------------------------

These three options control how your terminal interacts with the container process.

âš™ï¸ 1ï¸âƒ£ -i â†’ Interactive

Meaning:

Keeps STDIN (standard input) open, even if not attached.

It tells Docker:

â€œKeep the containerâ€™s input stream open â€” I might type something into it.â€

Example:

docker run -i ubuntu

Container runs, and STDIN remains open.

But no terminal interface (no colors, prompts, etc.) â€” just raw input/output.

ğŸ§  Think: You can type into the container, but youâ€™re blind â€” no proper terminal view.

Use Case:

When you want to pipe data into the container or run non-interactive scripts.

Example:

cat script.sh | docker run -i ubuntu bash

Here, youâ€™re sending script input into the container.

---
ğŸ–¥ï¸ 2ï¸âƒ£ -t â†’ TTY (pseudo-terminal)

Meaning:

Allocates a pseudo-TTY (a terminal interface like what you see in your shell).

It makes Docker act like a normal Linux terminal â€” it handles line breaks, colors, control keys, etc.

Example:

docker run -t ubuntu

Starts a container with a terminal-like interface.

If you run docker run -t ubuntu without -i, the container can keep running (the shell /bin/bash is in the foreground), but you cannot interact with it from the terminal because STDIN is not attached.

Output:

root@140846dd9f49:/# ls

ğŸ§  Think: You have a terminal, but you canâ€™t type into it (input closed).

Use Case:

Rarely used alone.

Used mostly in combination with -i.

---
ğŸ§© 3ï¸âƒ£ -it â†’ Interactive + Terminal (most common)

Meaning:

Combines both â€” keeps STDIN open and allocates a pseudo-terminal.

Example:

docker run -it ubuntu

You get a fully interactive shell inside the container (with prompt and color).

The session looks and feels like a normal Linux terminal.

Output:

root@a1b2c3d4:/#

You can run commands like:

apt update
ls /
echo "Hello"

ğŸ’¡ This is the most common combination for exploring or debugging containers.

---
âš™ï¸ 4ï¸âƒ£ -d â†’ Detached mode (background)

Meaning:

Runs the container in the background, without attaching your terminal.

You immediately get back the container ID:

docker run -d nginx

The container continues running in the background, and you can view it via:

docker ps

You can reattach later using:

docker attach <container_id>

or

docker exec -it <container_id> bash

ğŸ’¡ Typical for running services like web servers, databases, message brokers, etc.

---
ğŸ” 5ï¸âƒ£ Combinations and When to Use Each

| Command                                | Behavior                                                     | Typical Use Case                                         |
| -------------------------------------- | ------------------------------------------------------------ | -------------------------------------------------------- |
| `docker run ubuntu`                    | Runs container, exits immediately (no TTY or input open)     | Used rarely; mostly for containers that finish instantly |
| `docker run -i ubuntu`                 | STDIN open, but no TTY                                       | When piping data to container                            |
| `docker run -t ubuntu`                 | Has terminal, but no open input â†’ exits                      | Rarely used                                              |
| `docker run -it ubuntu`                | Interactive shell, full terminal                             | Debugging, exploration, manual testing                   |
| `docker run -d ubuntu`                 | Detached mode, background                                    | Long-running services                                    |
| `docker run -dit ubuntu`               | Detached + interactive shell (runs in background with a TTY) | Start container with TTY for later attach                |
| `docker run -dit --name mytest ubuntu` | Run Ubuntu in background but allow later attach              | For keeping debugging containers running persistently    |

--
ğŸ§  6ï¸âƒ£ Real-World Examples

ğŸ§© Case 1 â€” Debugging or exploring container manually

docker run -it ubuntu

â†’ You want to interact with it, run commands, test scripts.
--
ğŸ§© Case 2 â€” Running a web server

docker run -d -p 8080:80 nginx

â†’ You donâ€™t need to see terminal logs; runs in background.

--
ğŸ§© Case 3 â€” Want to start container detached but keep ability to attach later

docker run -dit --name debugbox ubuntu

â†’ Start container silently, and attach anytime with:

docker attach debugbox

--
ğŸ§© Case 4 â€” Pipe input data

cat data.txt | docker run -i ubuntu cat

â†’ Input data from file is piped into container.

---
ğŸ§± 1ï¸âƒ£ Understanding Docker flag parsing

Docker (and most Linux CLI tools) treats multiple single-letter flags combined in any order as equivalent to specifying them individually.

docker run -di is the same as docker run -id
docker run -dt is the same as docker run -td

So flag order doesnâ€™t matter; Docker just parses each character.

--
âš™ï¸ 2ï¸âƒ£ Breaking Down -di (-d -i)

Meaning:

-d â†’ detached mode (run container in background)

-i â†’ keep STDIN open

Behavior:

docker run -di ubuntu

Starts container in background (-d).

Keeps STDIN open (-i), meaning you could theoretically attach to the container later and have interactive input.

No TTY allocated, because -t is missing.

Example:

docker run -di --name test1 ubuntu tail -f /dev/null

tail -f /dev/null keeps the container running indefinitely.

Container runs in background.

You can attach input later using:

docker attach test1

But without -t, your terminal behaves weirdly â€” no proper prompts, colors, or line-editing. Input works but looks â€œraw.â€

ğŸ’¡ Key point: -di is useful if you want a background container that keeps STDIN open for programmatic input, but not for interactive shell exploration.

--
âš™ï¸ 3ï¸âƒ£ Breaking Down -dt (-d -t)

Meaning:

-d â†’ detached mode

-t â†’ allocate a TTY

Behavior:

docker run -dt ubuntu

Starts container in background (-d).

Allocates pseudo-terminal (-t) â†’ makes process think it has a terminal.

STDIN is not open because -i is missing.

Example:

docker run -dt --name test2 ubuntu bash

Container runs in background.

TTY is allocated, so processes that require a terminal wonâ€™t fail.

But you cannot type input directly, because STDIN is closed.

To get a proper shell later, you would still use:

docker exec -it test2 bash

ğŸ’¡ Key point: -dt is useful when running background containers that need a terminal for processes (some programs fail if TTY is missing), but you donâ€™t need STDIN open.

---
âš¡ 4ï¸âƒ£ Comparison Table of Less Common Combinations

| Flags  | Behavior                      | Use Case                                                                                                           |
| ------ | ----------------------------- | ------------------------------------------------------------------------------------------------------------------ |
| `-di`  | Background + keep STDIN open  | Background container that may receive piped input later                                                            |
| `-dt`  | Background + TTY allocated    | Run a background process that needs a TTY (e.g., interactive tools like top, bash, or programs expecting terminal) |
| `-dit` | Background + TTY + STDIN open | Fully interactive background container (attach later to work interactively)                                        |

--
ğŸ§© 5ï¸âƒ£ Real Examples

5.1 -di

docker run -di --name di_example ubuntu tail -f /dev/null

docker attach di_example

Container runs in background.

You attach input later.

No TTY â†’ shell looks raw, minimal editing capabilities.

--
5.2 -dt

docker run -dt --name dt_example ubuntu top

docker logs dt_example

Container runs background top command.

TTY exists â†’ top works without errors.

Cannot interact with it via input directly (STDIN closed).

--
5.3 -dit (for completeness)

docker run -dit --name dit_example ubuntu bash

docker attach dit_example

Fully interactive background container.

You can attach anytime and get proper shell with TTY and input.

------------------------
------------------------
ğŸ”¹ Core Concept: Main Process Determines Container Life
------------------------
------------------------

In Docker:

Every container runs a single main process (PID 1).

The container stays alive as long as that process runs.

Flags like -i, -t, or -d do not change whether the container stays alive; they only affect how you interact with the container.

1ï¸âƒ£ Foreground vs Background

Foreground:

docker run ubuntu tail -f /dev/null (Runs attached to your terminal (FG))

You see logs/output directly.

Pressing Ctrl+C stops the container (unless detached using -d).

Background (Detached):

docker run -d ubuntu tail -f /dev/null (Runs in background (detached).)

Container is alive in background.

Logs can be checked via docker logs <container>.

Observation:

Main process (tail -f /dev/null) is running in both cases.

Container stays alive regardless of interactive flags or foreground/background.

******* A Docker containerâ€™s lifecycle is dictated entirely by its main process. 
Flags like -i, -t, and -d only control interaction mode and terminal allocation. 
If the main process is long-running, the container will stay alive regardless of foreground or background execution. 
Short-lived processes exit immediately in both modes ******

--------

ğŸ“ Docker -i, -t, -d Combination Behavior Table with default processor (cmd /bin/bash) using ubuntu image (****If we use default running processor of image such as bash or shell*****)

****** if Main process is running fine then there is no effect in running in foreground or backgrond without limitation of any parameter we use in running container*******

| Flags Combination          | Runs in FG/BG | Container Status (Default command `/bin/bash`)                                     | Reason / Explanation                                                                  | Interview Tip                                                                           |
| -------------------------- | ------------- | ---------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------- |
| None (`docker run ubuntu`) | Foreground    | Exited immediately                                                                 | No TTY, no STDIN â†’ bash exits instantly                                               | Default behavior; container needs a running main process                                |
| `-i`                       | Foreground    | Exited on Ctrl+D; alive if restarted                                               | STDIN open â†’ bash stays waiting for input. If input closes, process exits             | Useful for programmatic input; rarely used alone for interactive shell                  |
| `-t`                       | Foreground    | Exited                                                                             | TTY allocated but no input â†’ bash finds no input, exits                               | TTY alone doesnâ€™t keep container alive; usually combined with `-i`                      |
| `-it`                      | Foreground    | Alive while attached; exits on `exit`; background possible via `Ctrl+P Ctrl+Q`     | STDIN open + TTY â†’ interactive shell works properly                                   | Standard way for interactive exploration; detach without stopping using `Ctrl+P Ctrl+Q` |
| `-d`                       | Background    | Exited immediately                                                                 | Detached mode alone â†’ bash runs, exits immediately because main process finishes      | Detached mode requires long-running process to stay alive                               |
| `-di`                      | Background    | Alive if main process is long-running (`tail -f /dev/null` or bash)                | Detached + STDIN open â†’ container can stay alive; process must not finish immediately | Useful for background containers expecting input later                                  |
| `-dt`                      | Background    | Alive if main process is long-running (`top` or bash)                              | Detached + TTY â†’ some programs require terminal; without it, may fail                 | TTY ensures processes that need terminal donâ€™t crash in background                      |
| `-dit`                     | Background    | Alive; fully attachable anytime                                                    | Detached + STDIN open + TTY â†’ fully interactive background container                  | Best practice for debugging or interactive background containers                        |

Flags           | Behavior                         | Use Case
----------------|---------------------------------|----------------------------------
none            | Exits immediately               | Default behavior
-i              | Waits for input                  | Programmatic input
-t              | Exits if no input                | TTY allocation only
-it             | Interactive shell                | Explore container interactively
-d              | Exits unless long-running proc   | Background process must be long-running
-di             | Background + STDIN open          | Background with possible input
-dt             | Background + TTY                 | Background programs requiring terminal
-dit            | Background + TTY + STDIN         | Full interactive background container

---
âš¡ 8ï¸âƒ£ Advanced Tip: Attaching / Detaching Controls

When you run a container interactively (-it), you can detach from it without stopping it.

ğŸ‘‰ Default detach keys: Ctrl + P then Ctrl + Q

This keeps the container running in background.

You can later reattach using:

docker attach <container_name>

If you want to change the detach key sequence (say you use tmux or vim), use:

docker run -it --detach-keys="ctrl-x,x" ubuntu

---
ğŸ§° 9ï¸âƒ£ Example: Combining -it and -d with docker exec

Sometimes you want to:

Run a container in background.

Then open a shell inside it later.

Example:

docker run -d --name web nginx
docker exec -it web bash

Here:

docker run -d â†’ starts background service.

docker exec -it â†’ attaches a new interactive shell to inspect or debug.

This is preferred over running docker run -dit for long-term containers.

---
ğŸ 10ï¸âƒ£ Interview-Level Insights

ğŸ§© Q: Why does docker run -t ubuntu exit immediately?

A: Because thereâ€™s no open STDIN (-i missing), so the container has no input to keep running â€” the process ends instantly.

ğŸ§© Q: Whatâ€™s difference between -it and -dit?

A: -it: Runs interactively in foreground.

   -dit: Runs interactively but detached in background (can attach later).

ğŸ§© Q: If you run docker run -it ubuntu and press Ctrl+C â€” what happens?

A: It stops the container because Ctrl+C sends SIGINT to the containerâ€™s main process.

ğŸ§© Q: What happens when you detach using Ctrl+P Ctrl+Q?

A: The container continues running in background.

âœ… 11ï¸âƒ£ Best Practices Summary

| Goal                                                   | Best Option                        |
| ------------------------------------------------------ | ---------------------------------- |
| Run service / app in background                        | `-d`                               |
| Run interactive shell                                  | `-it`                              |
| Start container in background but want to attach later | `-dit`                             |
| Pipe data into container                               | `-i` only                          |
| Debug running container                                | `docker exec -it <container> bash` |
| Prevent accidental container stop when detaching       | Use `Ctrl+P Ctrl+Q`                |
